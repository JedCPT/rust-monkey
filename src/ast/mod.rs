/*
Author: Jedda Boyle
Contains: Abstract Syntax Tree.
The abstract syntax tree is generated by the parser.
It represents the program in a way that can be evaluated.
*/

// ================================================================================
// Imports
// ================================================================================

use super::enviroment::Enviroment;

use super::lexer::token::TokenType;
use super::lexer::token::Token;

use super::object::ObjectType;
use super::object::Object;
use super::object;

// Crate used to downcast objects to their actual type.
use downcast_rs::Downcast;

use std::cell::RefCell;
use std::rc::Rc;

// ================================================================================
// Traits for the type of nodes that make up the AST.
// ================================================================================

#[derive(PartialEq)]
pub enum NodeType {
    LetStatement,
    ReturnStatement,
    ExpressionStatement,
    BlockStatement,

    IdentifierExpression,
    IntegralExpression,
    BoolExpression,
    PrefixExpression,
    InfixExpression,
    IfElseExpression,
    FunctionExpression,
    CallExpression,
}

pub trait Node: Downcast {
    fn get_type(&self) -> NodeType;

    fn to_string(&self) -> String;

    // The eval function evaluautes the current node and then passes the result (which is of type
    // Object) up the AST to its parent node. Eventually the result of the program is at the root node.
    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object>;
}

impl_downcast!(Node);

// ================================================================================
// Nodes.
// ================================================================================

// Statement nodes

pub struct LetStatement {
    pub token: Token,
    pub value: Box<Node>,
    pub identifier: IdentifierExpression,
}

pub struct ReturnStatement {
    pub token: Token,
    pub value: Box<Node>,
}

pub struct ExpressionStatement {
    pub token: Token,
    pub value: Box<Node>,
}

pub struct BlockStatement {
    pub token: Token,
    pub statements: Vec<Box<Node>>,
}

// Expression nodes.

pub struct IdentifierExpression {
    pub token: Token,
}

pub struct IntegralExpression {
    pub token: Token,
    pub value: i64,
}

pub struct BoolExpression {
    pub token: Token,
    pub value: bool,
}

pub struct PrefixExpression {
    pub token: Token,
    pub right: Box<Node>,
}

pub struct InfixExpression {
    pub token: Token,
    pub left: Box<Node>,
    pub right: Box<Node>,
}

pub struct IfElseExpression {
    pub token: Token,
    pub condition: Box<Node>,
    pub consequence: Box<Node>,
    pub alternative: Option<Box<Node>>,
}

pub struct FunctionExpression {
    pub token: Token,
    pub parameters: Rc<Vec<Box<Node>>>,
    pub body: Rc<Box<Node>>,
}

pub struct CallExpression {
    pub token: Token,
    pub arguments: Vec<Box<Node>>,
    pub func_identifier: Box<Node>, // ast::IdentifierExpression
}

// ================================================================================
// Node trait implemetations.
// ================================================================================

// Implement Node for each statement.

impl Node for LetStatement {
    fn get_type(&self) -> NodeType {
        return NodeType::LetStatement;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        // value is the expression to the right of the equals sign.
        let value = self.value.eval(env.clone());
        if value.get_type() == ObjectType::Error {
            return value;
        }

        // Add value to the enviroment.
        env.borrow_mut()
            .insert(self.identifier.token.literal.clone(), value);

        return Rc::new(object::Null {});
    }

    fn to_string(&self) -> String {
        return format!(
            "[{} {} = {}]",
            self.token,
            self.identifier.to_string(),
            self.value.to_string()
        );
    }
}

impl Node for ReturnStatement {
    fn get_type(&self) -> NodeType {
        return NodeType::ReturnStatement;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        return self.value.eval(env);
    }

    fn to_string(&self) -> String {
        return format!("[{} {}]", self.token, self.value.to_string());
    }
}

impl Node for ExpressionStatement {
    fn get_type(&self) -> NodeType {
        return NodeType::ExpressionStatement;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        return self.value.eval(env);
    }

    fn to_string(&self) -> String {
        return format!("[{}]", self.value.to_string());
    }
}

impl Node for BlockStatement {
    fn get_type(&self) -> NodeType {
        return NodeType::BlockStatement;
    }

    // Each line the the block statement is evaluated as its own AST
    // but with the same env.
    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        let mut result: Rc<Object> = Rc::new(object::Null {});
        for statement in self.statements.iter().by_ref() {
            result = statement.eval(env.clone());
            if statement.get_type() == NodeType::ReturnStatement {
                return result;
            }
        }
        return result;
    }

    fn to_string(&self) -> String {
        let mut to_return = "".to_string();
        for statement in self.statements.iter().by_ref() {
            to_return.push_str(&statement.to_string());
            to_return.push('\n');
        }
        return to_return;
    }
}

// Implement Node for each expression.

impl Node for IntegralExpression {
    fn get_type(&self) -> NodeType {
        return NodeType::IntegralExpression;
    }

    fn eval(&self, _env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        return Rc::new(object::Integer { value: self.value });
    }

    fn to_string(&self) -> String {
        return format!("{}", self.token);
    }
}

impl Node for BoolExpression {
    fn get_type(&self) -> NodeType {
        return NodeType::BoolExpression;
    }

    fn eval(&self, _env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        return Rc::new(object::Boolean { value: self.value });
    }

    fn to_string(&self) -> String {
        return format!("{}", self.token);
    }
}

impl Node for IdentifierExpression {
    fn get_type(&self) -> NodeType {
        return NodeType::IdentifierExpression;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        // Fetch value of iderntifier from enviroment.
        let value = env.borrow().get(&self.token.literal);
        // let value = borrowed_env.get(&self.token.literal);

        if value.is_none() {
            return Rc::new(object::Error {
                message: format!("Variable {} is not in scope.", self.token.literal).to_string(),
            });
        }

        // Convert the value to the correct object type.
        if value.as_ref().unwrap().get_type() == ObjectType::Integer {
            let int_value = value
                .as_ref()
                .unwrap()
                .downcast_ref::<object::Integer>()
                .unwrap();
            return Rc::new(object::Integer {
                value: int_value.value,
            });
        }
        if value.as_ref().unwrap().get_type() == ObjectType::Boolean {
            let bool_value = value
                .as_ref()
                .unwrap()
                .downcast_ref::<object::Boolean>()
                .unwrap();
            return Rc::new(object::Boolean {
                value: bool_value.value,
            });
        }
        if value.as_ref().unwrap().get_type() == ObjectType::Function {
            let func_value = value
                .as_ref()
                .unwrap()
                .downcast_ref::<object::Function>()
                .unwrap();
            return Rc::new(object::Function {
                env: func_value.env.clone(),
                body: func_value.body.clone(),
                parameters: func_value.parameters.clone(),
            });
        }

        return Rc::new(object::Error {
            message: format!(
                "Variable {} in scope but there was an error extracting it from the enviroment.",
                self.token.literal
            )
            .to_string(),
        });
    }

    fn to_string(&self) -> String {
        return format!("{}", self.token);
    }
}

impl PrefixExpression {
    fn eval_minus_operator(&self, right: &Rc<Object>) -> Rc<Object> {
        let operand = right.downcast_ref::<object::Integer>();
        if operand.is_some() {
            let to_return = object::Integer {
                value: -operand.unwrap().value,
            };
            return Rc::new(to_return);
        }
        // The downcast was not successful so the operand is not an integer.
        return Rc::new(object::Error {
            message: "Error: Prefix operand is not an integer as expected".to_string(),
        });
    }

    fn eval_bang_operator(&self, right: &Rc<Object>) -> Rc<Object> {
        let operand = right.downcast_ref::<object::Boolean>();
        if operand.is_some() {
            let to_return = object::Boolean {
                value: !operand.unwrap().value,
            };
            return Rc::new(to_return);
        }
        // The downcast was not successful so the operand is not an bool.
        return Rc::new(object::Error {
            message: "Error: Prefix operand is not a boolean as expected".to_string(),
        });
    }
}

impl Node for PrefixExpression {
    fn get_type(&self) -> NodeType {
        return NodeType::PrefixExpression;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        let right = self.right.eval(env.clone());
        if right.get_type() == ObjectType::Error {
            return right;
        }

        match self.token.token_type {
            TokenType::Bang => {
                return self.eval_bang_operator(&right);
            }
            TokenType::Minus => {
                return self.eval_minus_operator(&right);
            }
            _ => {
                return Rc::new(object::Error {
                    message: "Error: Not a valid prefix operator.".to_string(),
                });
            }
        }
    }

    fn to_string(&self) -> String {
        return format!("[{} {}]", self.token, self.right.to_string());
    }
}

impl InfixExpression {
    fn eval_boolean_infix_expression(&self, left: &Rc<Object>, right: &Rc<Object>) -> Rc<Object> {
        // The type of left and right has already been checked so unwrap can be done safely.
        let l_value = left.downcast_ref::<object::Boolean>().unwrap().value;
        let r_value = right.downcast_ref::<object::Boolean>().unwrap().value;

        // Compute expression.
        let value = match self.token.token_type {
            TokenType::Equal => Some(l_value == r_value),
            TokenType::NotEqual => Some(l_value != r_value),
            _ => None,
        };

        return Rc::new(object::Boolean {
            value: value.unwrap(),
        });
    }

    fn eval_integer_infix_expression(&self, left: &Rc<Object>, right: &Rc<Object>) -> Rc<Object> {
        // The type of left and right has already been checked so unwrap can be done safely.
        let l_value = left.downcast_ref::<object::Integer>().unwrap().value;
        let r_value = right.downcast_ref::<object::Integer>().unwrap().value;

        // Two matches are required to deduce the operator because some operators
        // can result in integers or booleans.

        // Check if operand is +, -, * or /
        let int_value = match self.token.token_type {
            TokenType::Plus => Some(l_value + r_value),
            TokenType::Minus => Some(l_value - r_value),
            TokenType::Asterisk => Some(l_value * r_value),
            TokenType::Slash => Some(l_value / r_value),
            _ => None,
        };
        if int_value.is_some() {
            return Rc::new(object::Integer {
                value: int_value.unwrap(),
            });
        }

        // Operand not matched so try match it again.
        let bool_value = match self.token.token_type {
            TokenType::Lt => Some(l_value < r_value),
            TokenType::Gt => Some(l_value > r_value),
            TokenType::Equal => Some(l_value == r_value),
            TokenType::NotEqual => Some(l_value != r_value),
            _ => None,
        };
        if bool_value.is_some() {
            return Rc::new(object::Boolean {
                value: bool_value.unwrap(),
            });
        }
        return Rc::new(object::Error {
            message: "Integer infix being evaluated with invalid operand.".to_string(),
        });
    }
}

impl Node for InfixExpression {
    fn get_type(&self) -> NodeType {
        return NodeType::InfixExpression;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        let r_operand = self.right.eval(env.clone());
        let l_operand = self.left.eval(env.clone());

        // Check if it is an integer operation.
        if r_operand.get_type() == ObjectType::Integer
            && l_operand.get_type() == ObjectType::Integer
        {
            return self.eval_integer_infix_expression(&l_operand, &r_operand);
        }
        // Check if it is a boolean operation.
        else if r_operand.get_type() == ObjectType::Boolean
            && l_operand.get_type() == ObjectType::Boolean
        {
            return self.eval_boolean_infix_expression(&l_operand, &r_operand);
        }
        // Error
        else {
            return Rc::new(object::Error {
                message: "The operand types don't match.".to_string(),
            });
        }
    }

    fn to_string(&self) -> String {
        return format!(
            "[{} {} {}]",
            self.left.to_string(),
            self.token,
            self.right.to_string()
        );
    }
}

impl Node for IfElseExpression {
    fn get_type(&self) -> NodeType {
        return NodeType::IfElseExpression;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        // Evaluate the condition.
        let condition = self.condition.eval(env.clone());
        if condition.get_type() != ObjectType::Boolean {
            if condition.get_type() == ObjectType::Error {
                return condition;
            } else {
                return Rc::new(object::Error {
                    message: "Condition is not of boolean type.".to_string(),
                });
            }
        }

        // Given condition evaluate the correct block statement.
        let bool_condition = condition.downcast_ref::<object::Boolean>().unwrap();
        if bool_condition.value == true {
            return self.consequence.eval(env.clone());
        }
        // Evaluate alternative it is exists.
        else if self.alternative.is_some() {
            return self.alternative.as_ref().unwrap().eval(env.clone());
        }
        // Do nothing.
        else {
            return Rc::new(object::Null {});
        }
    }

    fn to_string(&self) -> String {
        if self.alternative.is_none() {
            return format!(
                "{} {} do \n{}",
                self.token,
                self.condition.to_string(),
                self.consequence.to_string()
            );
        }
        return format!(
            "{} {} do \n{}else do \n{}",
            self.token,
            self.condition.to_string(),
            self.consequence.to_string(),
            self.alternative.as_ref().unwrap().to_string()
        );
    }
}

impl Node for FunctionExpression {
    fn get_type(&self) -> NodeType {
        return NodeType::FunctionExpression;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        // Return function object.
        let to_return = object::Function {
            body: self.body.clone(),
            parameters: self.parameters.clone(),
            // Create new enviroment which holds data within the function's scope.
            env: Rc::new(RefCell::new(Enviroment::new(Some(env.clone())))),
        };

        return Rc::new(to_return);
    }

    fn to_string(&self) -> String {
        let mut to_return = format!("{} (", self.token);
        for par in self.parameters.iter().by_ref() {
            to_return.push_str(&par.to_string());
            to_return.push(',')
        }
        if self.parameters.len() != 0 {
            to_return.pop(); // Remove trailing comma
        }
        to_return.push_str(&")\n".to_string());
        to_return.push_str(&self.body.to_string());
        return to_return;
    }
}

impl CallExpression {
    fn eval_arguments(&self, env: Rc<RefCell<Enviroment>>) -> Vec<Rc<Object>> {
        let mut to_return: Vec<Rc<Object>> = Vec::new();
        let mut result: Rc<Object>;
        for arg in self.arguments.iter().by_ref() {
            result = arg.eval(env.clone());
            if result.get_type() == ObjectType::Error {
                to_return.clear();
                to_return.push(result);
                return to_return;
            }
            to_return.push(result);
        }

        return to_return;
    }

    fn eval_func(
        &self,
        func: Rc<Object>,
        args: Vec<Rc<Object>>,
        outer_env: Rc<RefCell<Enviroment>>,
    ) -> Rc<Object> {
        // Create a new enviroment for the scope of the function being called.
        let env = Rc::new(RefCell::new(Enviroment::new(Some(outer_env.clone()))));

        let function_object = func.downcast_ref::<object::Function>();
        if function_object.is_none() {
            return Rc::new(object::Error {
                message: format!("Error in calling function").to_string(),
            });
        }

        // Assign the value to the enviroment.
        // parameters is a vector of identifier_expressions where token.literal is the name.
        // par := the name of the parameter
        // arg := the value being passed into the function.
        for (par, arg) in function_object
            .as_ref()
            .unwrap()
            .parameters
            .iter()
            .zip(args)
        {
            let parameter = par.downcast_ref::<IdentifierExpression>().unwrap();
            env.borrow_mut()
                .insert(parameter.token.literal.clone(), arg);
        }

        let result = function_object.as_ref().unwrap().body.eval(env);

        if result.get_type() == ObjectType::Error {
            return Rc::new(object::Error {
                message: format!("Error in calling function").to_string(),
            });
        }
        return result;
    }
}

impl Node for CallExpression {
    fn get_type(&self) -> NodeType {
        return NodeType::CallExpression;
    }

    fn eval(&self, env: Rc<RefCell<Enviroment>>) -> Rc<Object> {
        // func_identifier is type ast::IdentifierExpression so evaluating it
        // looks into env and tries to return the associated value.
        // Since the idenifier is looking for a function the result is of
        // type object::Function
        let func = self.func_identifier.eval(env.clone());
        if func.get_type() != ObjectType::Function {
            return Rc::new(object::Error {
                message: "Called function is not in scope.".to_string(),
            });
        }

        let arguments = self.eval_arguments(env.clone());
        if arguments.len() == 1 && arguments[0].get_type() == ObjectType::Error {
            return Rc::new(object::Error {
                message: "Couldn't evaluate function arguments.".to_string(),
            });
        }

        return self.eval_func(func, arguments, env.clone());
    }

    fn to_string(&self) -> String {
        let mut to_return = format!("[{} (", self.func_identifier.to_string());
        for arg in self.arguments.iter().by_ref() {
            to_return.push_str(&arg.to_string());
            to_return.push(',')
        }
        if self.arguments.len() != 0 {
            to_return.pop(); // Remove trailing comma
        }
        to_return.push_str(&")]".to_string());
        return to_return;
    }
}
